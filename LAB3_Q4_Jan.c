#pragma config(Motor,  motorB,          LEFT,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          RIGHT,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float currentAngularSpeedRight = 0, currentAngularSpeedLeft = 0,currentDistanceRight = 0, currentDistanceLeft = 0, distanceIncrement = 1,
																																					desiredSpeedRight = 30, desiredSpeedLeft;


const float tolerance = .05, rads = 6.28318, desiredDistanceINCHES = (360/(58 * PI)) * 12, secs = 60.0;

const int motorControlTaskDelay = 2000, slewRate = 5, k = 2;

float errorRight, errorLeft;


task driveDisplacementRight(){
		while(true){


			desiredSpeedRight = k*(desiredDistanceINCHES - currentDistanceRight);
			currentAngularSpeedRight = (((getMotorRPM(RIGHT) * rads)/secs) * sgn(getMotorSpeed(RIGHT))) * (2*PI);

			errorRight = desiredDistanceINCHES - currentDistanceRight;
			displayTextLine(1,"%s: %f","currentSpeedRight", currentAngularSpeedRight);
			displayTextLine(2,"%s: %f","desiredSpeedRight", desiredSpeedRight);
			displayTextLine(3,"%s: %f","errorRight", errorRight);
			displayTextLine(4,"%s: %f","currentDistanceRight", currentDistanceRight);
			displayTextLine(5,"%s: %f","desiredDistanceINCHES", desiredDistanceINCHES);

			if(abs(errorRight) < tolerance){
				if(currentDistanceRight < (1/2 * (desiredDistanceINCHES))){
						if(currentAngularSpeedRight < desiredSpeedRight)
								currentAngularSpeedRight += slewRate;
						// end of currentAngularSpeedRight < desiredSpeedRight
				}else if(currentDistanceRight > 1/2 * (desiredDistanceINCHES)){
								currentAngularSpeedRight -= slewRate;
				}//end of else-if
			}//abs(errorRight)< tolerance

			distanceIncrement++;
			currentDistanceRight = (360/(58 * PI))* distanceIncrement;
	}//end while
}// end of driveDisplacement TASK


task driveDisplacementLeft(){
		while(true){

			currentAngularSpeedLeft = (((getMotorRPM(LEFT) * rads)/secs) * sgn(getMotorSpeed(LEFT))) * (2*PI);
			desiredSpeedLeft = k*(desiredDistanceINCHES - currentDistanceLeft);

			errorLeft = desiredDistanceINCHES - currentDistanceLeft;

			if(abs(errorRight)< tolerance){
				if(currentDistanceLeft < 1/2 * (desiredDistanceINCHES)){
						if(currentAngularSpeedLeft < desiredSpeedRight)
								currentAngularSpeedLeft += slewRate;
				}else if(currentDistanceLeft > 1/2 * (desiredDistanceINCHES)){
								currentAngularSpeedLeft -= slewRate;
				}
			}//abs(errorRight)< tolerance

			distanceIncrement++;
			currentDistanceLeft = ((58 * PI)/360)* distanceIncrement;
	}//end while
}// end of driveDisplacement TASK

task main(){
	startTask(driveDisplacementRight);
	startTask(driveDisplacementLeft);

	while(true){
		setMotorSyncEncoder(RIGHT,LEFT,0,currentDistanceRight,currentAngularSpeedRight);
		setMotorSyncEncoder(LEFT,RIGHT,0,currentDistanceLeft,currentAngularSpeedLeft);
		sleep(motorControlTaskDelay);
	}

}
