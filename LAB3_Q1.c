#pragma config(Motor,  motorB,          LEFT,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          RIGHT,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int currentSpeedRight = 0, currentSpeedLeft = 0;

const float tolerance = 10, rads = 6.28318, desiredSpeed = 25.0, secs = 60.0;

const int motorControlTaskDelay = 500, slewRate = 5;

float errorRight, errorLeft;

/* Purpose: this algorithm implements a controlled increment in speed until
 * a desired speed is achieved for the right motor
 */

task speedControlTaskRightMotor(){
	while (true){
		displayTextLine(1,"%s:%i","Current speed R", currentSpeedRight);
		sleep(500);

		displayTextLine(2,"%s:%i","Current sgn R", sgn(getMotorSpeed(RIGHT)));
		sleep(500);

		currentSpeedRight = (((getMotorRPM(RIGHT) * rads)/secs) * (sgn(getMotorSpeed(RIGHT))) * (2*PI));

		sleep(500);

		displayTextLine(3,"%s:%i","Current angular speed R", currentSpeedRight);

		sleep(500);

		errorRight = currentSpeedRight - desiredSpeed;

		if((abs(errorRight)) > tolerance){

			if(currentSpeedRight < desiredSpeed){
					currentSpeedRight += slewRate;

			}else
				if (currentSpeedRight > desiredSpeed) {
				currentSpeedRight -= slewRate;
			}
		}// END of outer IF
		displayTextLine(4,"%s%i/%i","Current Speed R: ",currentSpeedRight, desiredSpeed);
	sleep(motorControlTaskDelay);
	} //end of WHILE
}//end of Task


/* Purpose: this algorithm implements a controlled increment in speed until
 * a desired speed is achieved for the left motor
 */

task speedControlTaskLeftMotor(){
	while (true){
		displayTextLine(6,"%s:%i","Current speed L", currentSpeedLeft);
		sleep(500);

		displayTextLine(7,"%s:%i","Current sgn L", sgn(getMotorSpeed(LEFT)));
		sleep(500);

		currentSpeedLeft = (((getMotorRPM(LEFT) * rads)/secs) * sgn(getMotorSpeed(LEFT))) * (2*PI);

		sleep(500);

		displayTextLine(8,"%s:%i","Current angular speed L", currentSpeedLeft);

		sleep(500);

		errorLeft = currentSpeedLeft - desiredSpeed;

		if((abs(errorLeft)) > tolerance){

			if(currentSpeedLeft < desiredSpeed){
					currentSpeedLeft  += slewRate;
			}else
				if (currentSpeedLeft > desiredSpeed) {
				currentSpeedLeft -= slewRate;
			}
		}// END of outer IF
		displayTextLine(9,"%s%i/%i","Current Speed Left: ",currentSpeedLeft, desiredSpeed);
	sleep(motorControlTaskDelay);
	} //end of WHILE
}//end of Task LEFT

task main()
{

	startTask(speedControlTaskRightMotor);
	startTask(speedControlTaskLeftMotor);

	while(true){

	setMotorSpeed(RIGHT, currentSpeedRight);
	setMotorSpeed(LEFT, currentSpeedLeft);

	}

}
