#pragma config(Motor,  motorB,          LEFT,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          RIGHT,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//GLOBAL VARIABLES

const float trackWidth = 120.0, diameter = 58.0, tolerance = .5;

const float desiredAngleU = (2*PI) * (180/PI), angleIncrease = PI/180; //angleIncrease is the equivalent of 1 degree in radians

const int motorControlTaskDelay = 65, slewRate = 10, k = 2 , maxMotorPower = 80, minMotorPower = 0, halfDistance = diameter/2;

float currentAnglePsi = 0, psiIncrement = 0, X_r, angularVelo, wR, wL;// psiIncrement is in radians
int currentPower = 0, desiredPower, error;




void turnRightSpeedControl(){

	desiredPower = 0;

	while(currentAnglePsi < desiredAngleU){

		error = (desiredAngleU - currentAnglePsi);

		if(abs(error) > tolerance){
			desiredPower = k*(desiredAngleU - currentAnglePsi);

			if(currentPower < desiredPower){

					if(currentPower + slewRate < desiredPower){
							currentPower +=slewRate;
					}else{
							currentPower = desiredPower;
							if(currentPower > maxMotorPower)
								currentPower = maxMotorPower;
						}

			}else{

						if(currentPower - slewRate > desiredPower){
				   			currentPower -= slewRate;
				 		}else{
				 				currentPower = desiredPower;
				 				if(currentPower < minMotorPower)
				 						currentPower =  minMotorPower;
						}
			}// end of INNER IF-ELSE
		}// end of OUTTER IF

		if(currentAnglePsi < desiredAngleU){
				//	psiIncrement will increase by the equivalent of 1 degree but in radians
				psiIncrement += (slewRate * angleIncrease);
				// caluculate new current angle based of psiIncrement and then convert it to degrees
				currentAnglePsi = ((trackWidth/2 * psiIncrement)* (2/diameter))*(180/PI);
		}else
			if(currentAnglePsi > desiredAngleU){
				//	psiIncrement will decrease by the equivalent of 1 degree but in radians
					psiIncrement -= (slewRate* angleIncrease);
				// caluculate new current angle based of psiIncrement and then convert it to degrees
					currentAnglePsi = ((trackWidth/2 * psiIncrement)* (2/diameter))*(180/PI);
				}
		wR = (getMotorRPM(RIGHT)) * (PI/180);
		wL = (getMotorRPM(LEFT)) * (PI/180);
		X_r =  halfDistance * (wR + wL);
		angularVelo = (diameter/trackWidth) * (wR - wL);
		displayTextLine(1,"%s: %i","currentAngle",currentAnglePsi);
		displayTextLine(2,"%s: %i","desiredAngle",desiredAngleU);
		displayTextLine(3,"%s: %i","X_r ",X_r);
		displayTextLine(4,"%s: %f","Angular Velocity", angularVelo);
		setMotorSync(RIGHT,LEFT,-100,currentPower);
		sleep(motorControlTaskDelay);

	}// end of WHILE
}// end of turnRightSpeedControl TASK


task main()
{
	turnRightSpeedControl();

}
